# 2024년 7월 22일 Today I Learned

## 이벤트에 응답하기
```jsx
export default function Button() {
  function handleClick() {
    alert('You clicked me!');
  }

  return (
    <button onClick={handleClick}>
      Click me
    </button>
  );
}
```
위 컴포넌트에서 Button의 handleClick 은 이벤트 핸들러 입니다.   
그 특징은 다음과 같습니다.   
1. 주로 컴포넌트 내부에서 정의됩니다.
2. handle로 시작하고 그 뒤에 이벤트명을 붙인 함수명을 가집니다.   
 ```jsx
 <button onClick={() => alert('You clicked me!')}>
 // 이런형식으로 람다식(화살표함수) 로도 전달가능!
 ```
 ```jsx
function Button({ onSmash, children }) {
  return (
    <button onClick={onSmash}>
      {children}
    </button>
  );
}

export default function App() {
  return (
    <div>
      <Button onSmash={() => alert('Playing!')}>
        Play Movie
      </Button>
      <Button onSmash={() => alert('Uploading!')}>
        Upload Image
      </Button>
    </div>
  );
}
// 이런식으로 태그의 텍스트와 메소드 그자체를 props로 넘기기 가능
 ```

 ## 이벤트 전파(bubble)
```jsx
export default function Toolbar() {
  return (
    <div className="Toolbar" onClick={() => {
      alert('You clicked on the toolbar!');
    }}>
      <button onClick={() => alert('Playing!')}>
        Play Movie
      </button>
      <button onClick={() => alert('Uploading!')}>
        Upload Image
      </button>
    </div>
  );
}
// 이러면 어떤 문구가 alert 될까?
```
정답은 누른 버튼의(더 자식인) 이벤트가 먼저 발생하고 부모의 이벤트가 발생한다!

```jsx
e => {
      e.stopPropagation();
      onClick();
}
``` 
으로 전파를 막을 수 있다!

## 기억 저장소 state
지역변수의 특징 
1. 지역 변수는 렌더링 간에 유지되지 않습니다.  React는 이 컴포넌트를 두 번째로 렌더링할 때 지역 변수에 대한 변경 사항은 고려하지 않고 처음부터 렌더링 합니다.
2. 지역 변수를 변경해도 렌더링을 일으키지 않습니다. React는 새로운 데이터로 컴포넌트를 다시 렌더링해야 한다는 것을 인식하지 못합니다.

React에서 useState와 같이 `“use”`로 시작하는 다른 모든 함수를 `훅`이라고 합니다.

### state의 용법
```jsx
import { useState } from 'react';
// 먼저 임포트하고
...
const [index, setIndex] = useState(0);
const [showMore, setShowMore] = useState(false);
// 선언 및 초기화 한다
// 괄호 안은 초깃값 설정
...
function handleNextClick() {
    setIndex(index + 1);
  }

  function handleMoreClick() {
    setShowMore(!showMore);
  }
// 위 두 메소드를 호출할때마다 , set 메소드들이 호출되면서 
// react는 그 컴포넌트를 렌더링하게 되어 갱신된다!

```
### 스테이트는 격리되고 비공개 다!
State는 화면에서 컴포넌트 인스턴스에 지역적입니다.   
  다시 말해, 동일한 컴포넌트를 두 번 렌더링한다면 각 복사본은 완전히 격리된 state를 가집니다!    
  그중 하나를 변경해도 다른 하나에는 영향을 미치지 않습니다.
  ```jsx
import Gallery from './Gallery.js';

export default function Page() {
  return (
    <div className="Page">
      <Gallery />
      <Gallery />
    </div>
  );
}
// 위코드의 Gallery 안의 state들은 별개로 작동한다!
  ```

  ## UI를 렌더링하는 세가지 과정

  ### 1. 렌더링 트리거

컴포넌트 렌더링을 일으키는 두가지 요인이 있습니다
1. 컴포넌트의 초기 렌더링인 경우
2. 컴포넌트의 state가 업데이트된 경우

  ### 2. 컴포넌트 렌더링
`렌더링` 이란 `"React에서 컴포넌트를 호출하는 것!"`
1. 초기 렌더링에서 React는 루트 컴포넌트를 호출합니다.
2. 이후 렌더링에서 React는 state 업데이트가 일어나 렌더링을 트리거한 컴포넌트를 호출합니다.
  ### 3. React가 DOM에 변경사항을 커밋 
컴포넌트를 렌더링(호출)한 후 React는 DOM을 수정합니다.

1. 초기 렌더링의 경우 React는 appendChild() DOM API를 사용하여 생성한 모든 DOM 노드를 화면에 표시합니다.
2. 리렌더링의 경우 React는 필요한 최소한의 작업(렌더링하는 동안 계산된 것!)을 적용하여 DOM이 최신 렌더링 출력과 일치하도록 합니다.
`React는 렌더링 간에 차이가 있는 경우에만 DOM 노드를 변경합니다`

## 스냅샷으로서의 state
React는 렌더링할때 그 state의 스냅샷을 찍습니다
state 변수의 값은 이벤트 핸들러의 `코드가 비동기적이더라도 렌더링 내에서 절대 변경되지 않습니다.` 

## state 업데이트 큐
React는 state 업데이트를 하기 전에 이벤트 핸들러의 모든 코드가 실행될 때까지 기다립니다. 

## 객체 state 업데이트 하기
`State는 객체를 포함한 모든 종류의 자바스크립트 값을 가질 수 있습니다. 하지만 리액트 state가 가진 객체를 직접 변경해서는 안 됩니다. 객체를 업데이트하고 싶을 때는 새로운 객체를 생성하여 (또는 기존 객체의 복사본을 만들어), state가 복사본을 사용하도록 하세요.`

## 배열 state 업데이트 하기
`배열은 JavaScript에서는 변경이 가능하지만, state로 저장할 때에는 변경할 수 없도록 처리해야 합니다. 객체와 마찬가지로, state에 저장된 배열을 업데이트하고 싶을 때에는, 새 배열을 생성(혹은 기존 배열의 복사본을 생성)한 뒤, 이 새 배열을 state로 두어 업데이트해야 합니다`

### Immer?
```jsx
updatePerson(draft => {
  draft.artwork.city = 'Lagos';
});
// 뭐야 state를 직접 변경하지 말라며?
```
`Immer가 제공하는 draft는 Proxy라고 하는 아주 특별한 객체 타입으로, 당신이 하는 일을 “기록” 합니다. 객체를 원하는 만큼 자유롭게 변경할 수 있는 이유죠! Immer는 내부적으로 draft의 어느 부분이 변경되었는지 알아내어, 변경사항을 포함한 완전히 새로운 객체를 생성합니다.`